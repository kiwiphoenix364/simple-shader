<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="AzOfe,6?2$Cv4Py!GpK:" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="9WnsFiTyGk2H,[W(F`/7" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class ShaderPack {&#13;" line1="    private colorNames: string[]&#13;" line2="    private shaderColorSets: any[]&#13;" line3="    constructor(colorNames: string[], shaderColorSets: any[]) {&#13;" line4="        this.colorNames = colorNames&#13;" line5="        this.shaderColorSets = shaderColorSets&#13;" line6="    }&#13;" line7="    public unpack () {&#13;" line8="        //let buf = Buffer.create(16)&#13;" line9="        //for (let i = 0; i &lt; this.shaderColorSets.length; i++) {&#13;" line10="        //    buf = buf.concat(this.shaderColorSets[i])&#13;" line11="        //}&#13;" line12="        let buf = [Buffer.create(0)]&#13;" line13="        for (let i = 0; i &lt; this.shaderColorSets.length; i++) {&#13;" line14="            buf.push(Buffer.fromArray(this.shaderColorSets[i]))&#13;" line15="        }&#13;" line16="        return buf&#13;" line17="    }&#13;" line18="    public getTintIdx (color: string) {&#13;" line19="        return this.colorNames.indexOf(color) + 1&#13;" line20="    }&#13;" line21="    static get (shader: string) {&#13;" line22="        //reference for shader pack format&#13;" line23="        //color sets and color set names are in respective orders in their arrays&#13;" line24="        //shader arrays go in order of colors on the screen, so the fifth item in the array ([4]) will be color four&#13;" line25="        let packNames = [&quot;default&quot;]&#13;" line26="        let packs = [&#13;" line27="            new ShaderPack(&#13;" line28="                [&quot;light&quot;, &quot;light2&quot;, &quot;dark&quot;, &quot;dark2&quot;, &quot;yellow&quot;, &quot;yellow2&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;],&#13;" line29="                [&#13;" line30="                    [0, 1, 4, 1, 5, 1, 7, 5, 9, 1, 11, 1, 10, 1, 2, 12],&#13;" line31="                    [0, 1, 5, 1, 1, 1, 5, 1, 1, 1, 1, 1, 11, 1, 4, 10],&#13;" line32="                    [0, 13, 14, 2, 2, 7, 8, 6, 12, 6, 12, 12, 15, 14, 15, 15],&#13;" line33="                    [0, 14, 15, 14, 14, 6, 12, 8, 15, 8, 15, 15, 15, 15, 15, 15],&#13;" line34="                    [0, 13, 4, 4, 5, 5, 7, 5, 6, 13, 11, 13, 11, 5, 13, 14],&#13;" line35="                    [0, 5, 5, 5, 5, 5, 5, 5, 7, 5, 13, 5, 13, 5, 5, 13],&#13;" line36="                    [0, 3, 2, 2, 2, 4, 11, 4, 10, 11, 2, 2, 10, 4, 2, 14],&#13;" line37="                    [0, 5, 4, 13, 5, 7, 7, 7, 6, 6, 12, 7, 7, 7, 5, 8],&#13;" line38="                    [0, 9, 10, 11, 12, 6, 8, 6, 8, 8, 12, 8, 8, 9, 12, 8],&#13;" line39="                    [0, 11, 10, 10, 11, 4, 10, 12, 10, 11, 10, 10, 10, 11, 12, 12]&#13;" line40="                ]&#13;" line41="            )&#13;" line42="        ]&#13;" line43="        &#13;" line44="        //for generating the &quot;2&quot; varients&#13;" line45="        let test = []&#13;" line46="        let sample = [0, 1, 4, 1, 5, 1, 7, 5, 9, 1, 11, 1, 10, 1, 2, 12]&#13;" line47="        for (let j = 0; j &lt; 16; j++) {&#13;" line48="            test.push(sample[sample[j]])&#13;" line49="        }&#13;" line50="        &#13;" line51="        return packs[packNames.indexOf(shader)]&#13;" line52="    }&#13;" line53="}" numlines="54"></mutation><next><block type="typescript_statement" id="oXq^yM+c4wmQ!Pb~;ex(" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Shader {&#13;" line1="    //Declare initial variables&#13;" line2="    //lookup table&#13;" line3="    //lkupx16: Buffer&#13;" line4="    //Shader pack&#13;" line5="    public refreshShaderLayer: boolean&#13;" line6="    private currentShader: ShaderPack&#13;" line7="    //Decompiled shader pack&#13;" line8="    private colbuf: Buffer[]&#13;" line9="    //Shader augment image&#13;" line10="    public mapLayer: Image&#13;" line11="    //Render and shader buffers&#13;" line12="    private renderBuf: Buffer&#13;" line13="    private shaderBuf: Buffer&#13;" line14="    //zValue&#13;" line15="    private zValue: number&#13;" line16="    //Renderable for shader&#13;" line17="    private shader: scene.Renderable&#13;" line18="    private destroyHandler: () =&gt; void&#13;" line19="    constructor(currentShader: ShaderPack, refreshShaderLayer: boolean, zValue = 0) {&#13;" line20="        /*&#13;" line21="        //build lookup table&#13;" line22="        this.lkupx16 = Buffer.create(16)&#13;" line23="        for (let i = 0; i &lt; 16; i++) {&#13;" line24="            this.lkupx16[i] = (i * 16)&#13;" line25="        }&#13;" line26="        */&#13;" line27="        this.refreshShaderLayer = refreshShaderLayer&#13;" line28="        this.zValue = zValue&#13;" line29="        this.currentShader = currentShader&#13;" line30="        //Unpack Shaderpack&#13;" line31="        this.colbuf = this.currentShader.unpack()&#13;" line32="        //create buffer image&#13;" line33="        this.mapLayer = image.create(160, 120)&#13;" line34="        this.renderBuf = Buffer.create(120)&#13;" line35="        this.shaderBuf = Buffer.create(120)&#13;" line36="        this.shader = scene.createRenderable(this.zValue, (screenImg: Image, camera: scene.Camera) =&gt; {&#13;" line37="            this.shadeImg(screenImg)&#13;" line38="        })&#13;" line39="        this.updateShaderLayer()&#13;" line40="    }&#13;" line41="    protected shadeImg(img:Image) {&#13;" line42="        for (let x = 0; x &lt; img.width; ++x) {&#13;" line43="            img.getRows(x, this.renderBuf)&#13;" line44="            this.mapLayer.getRows(x, this.shaderBuf)&#13;" line45="            for (let y = 0; y &lt; img.height; ++y) {&#13;" line46="                if (this.shaderBuf[y]) {&#13;" line47="                    this.renderBuf[y] = this.colbuf[this.shaderBuf[y]][this.renderBuf[y]]&#13;" line48="                    //use alternate compilation format&#13;" line49="                    //this.renderBuf[y] = (this.colbuf[this.renderBuf[y] + Math.imul(this.shaderBuf[y], 16)])&#13;" line50="                    //alt comp format + lookup table&#13;" line51="                    //this.renderBuf[y] = (this.colbuf[this.renderBuf[y] + this.lkupx16[this.shaderBuf[y]]])&#13;" line52="                }&#13;" line53="            }&#13;" line54="            img.setRows(x, this.renderBuf)&#13;" line55="        }&#13;" line56="    }&#13;" line57="    protected updateShaderLayer() {&#13;" line58="        game.currentScene().eventContext.registerFrameHandler(17, () =&gt; {&#13;" line59="            if (this.refreshShaderLayer) {&#13;" line60="                this.mapLayer = image.create(160,120)&#13;" line61="            }&#13;" line62="        })&#13;" line63="        game.currentScene().eventContext.registerFrameHandler(24, () =&gt; {&#13;" line64="            &#13;" line65="        })&#13;" line66="    }&#13;" line67="    public setNewShader (shader: ShaderPack) {&#13;" line68="        this.colbuf = shader.unpack()&#13;" line69="    }&#13;" line70="    public onDestroyed(handler: () =&gt; void) {&#13;" line71="        this.destroyHandler = handler&#13;" line72="    }&#13;" line73="    /*&#13;" line74="    //alt function&#13;" line75="    directSetUnpackedShader(array: Buffer) {&#13;" line76="        this.colbuf = shader&#13;" line77="    }&#13;" line78="    */&#13;" line79="    public directSetUnpackedShader (shader: Buffer[]) {&#13;" line80="        this.colbuf = shader&#13;" line81="    }&#13;" line82="    static toScreenX(val: number) {&#13;" line83="        return val - scene.cameraProperty(CameraProperty.Left)&#13;" line84="    }&#13;" line85="    static toScreenY(val: number) {&#13;" line86="        return val - scene.cameraProperty(CameraProperty.Top)&#13;" line87="    }&#13;" line88="    public destroy() {&#13;" line89="        this.refreshShaderLayer = this.currentShader = this.colbuf = this.mapLayer = this.renderBuf = this.shaderBuf = this.zValue = this.shader = this.destroyHandler = null&#13;" line90="    }&#13;" line91="}" numlines="92"></mutation><next><block type="typescript_statement" id=",`qI*n7`5bfn|q%FsyQ7" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class ShaderAttachSprite {&#13;" line1="    public sprite: Sprite&#13;" line2="    public shader: Shader&#13;" line3="    public tint: number&#13;" line4="    public radius: number&#13;" line5="    private currentRad: number&#13;" line6="    public flux: number&#13;" line7="    public smoothness: number&#13;" line8="    public xOffset = 0&#13;" line9="    public yOffset = 0&#13;" line10="    protected updater: any&#13;" line11="    constructor(sprite: Sprite, shader: Shader, tint = 1, radius = 5, flux = 0, smoothness = 1) {&#13;" line12="        this.sprite = sprite&#13;" line13="        this.shader = shader&#13;" line14="        this.tint = tint&#13;" line15="        this.radius = radius&#13;" line16="        this.currentRad = this.radius&#13;" line17="        this.flux = flux&#13;" line18="        this.smoothness = smoothness&#13;" line19="        this.updateLightSources()&#13;" line20="        this.sprite.onDestroyed(() =&gt; {&#13;" line21="            this.destroy()&#13;" line22="        })&#13;" line23="        this.shader.onDestroyed(() =&gt; {&#13;" line24="            this.destroy()&#13;" line25="        })&#13;" line26="    }&#13;" line27="    protected updateLightSources() {&#13;" line28="        this.updater = game.currentScene().eventContext.registerFrameHandler(23, () =&gt; {&#13;" line29="            this.updateFlux()&#13;" line30="            this.shader.mapLayer.fillCircle(Shader.toScreenX(this.sprite.x) + this.xOffset, Shader.toScreenY(this.sprite.y) + this.yOffset, Math.round(this.currentRad), this.tint)&#13;" line31="        })&#13;" line32="        //game.currentScene().eventContext.unregisterFrameHandler(controller)&#13;" line33="    }&#13;" line34="    protected updateFlux() {&#13;" line35="        this.smoothness = Math.constrain(this.smoothness, Math.abs(this.flux) * -2, Math.abs(this.flux) * 2)&#13;" line36="        this.currentRad += Math.randomRange(0 - this.smoothness, this.smoothness)&#13;" line37="        //this.currentRad = Math.constrain(this.currentRad, this.radius + this.flux, this.radius - this.flux)&#13;" line38="        if (this.currentRad &gt; this.radius + this.flux || this.currentRad &lt; this.radius - this.flux) {&#13;" line39="            this.currentRad -= this.currentRad - (this.radius + this.flux)&#13;" line40="        }&#13;" line41="    }&#13;" line42="    public destroy() {&#13;" line43="        game.currentScene().eventContext.unregisterFrameHandler(this.updater)&#13;" line44="        this.sprite = this.shader = this.tint = this.radius = this.currentRad = this.flux = this.smoothness = this.xOffset = this.yOffset = this.updater = null&#13;" line45="    }&#13;" line46="}" numlines="47"></mutation></block></next></block></next></block></statement></block></xml>