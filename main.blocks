<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="nzp0%TWtoJSjW96v0kCX" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="H`$]J?5/FU]T^`N1gj[0" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class ShaderPack {&#13;" line1="    private colorNames: string[]&#13;" line2="    private shaderColorSets: any[]&#13;" line3="    constructor(colorNames: string[], shaderColorSets: any[]) {&#13;" line4="        this.colorNames = colorNames&#13;" line5="        this.shaderColorSets = shaderColorSets&#13;" line6="    }&#13;" line7="    public unpack () {&#13;" line8="        //let buf = Buffer.create(16)&#13;" line9="        //for (let i = 0; i &lt; this.shaderColorSets.length; i++) {&#13;" line10="        //    buf = buf.concat(this.shaderColorSets[i])&#13;" line11="        //}&#13;" line12="        let buf = [Buffer.create(0)]&#13;" line13="        for (let i = 0; i &lt; this.shaderColorSets.length; i++) {&#13;" line14="            buf.push(Buffer.fromArray(this.shaderColorSets[i]))&#13;" line15="        }&#13;" line16="        return buf&#13;" line17="    }&#13;" line18="    public getTintIdx (color: string) {&#13;" line19="        return this.colorNames.indexOf(color) + 1&#13;" line20="    }&#13;" line21="    public destroy() {&#13;" line22="        this.colorNames = this.shaderColorSets = null&#13;" line23="    }&#13;" line24="    static get (shader: string) {&#13;" line25="        //reference for shader pack format&#13;" line26="        //color sets and color set names are in respective orders in their arrays&#13;" line27="        //shader arrays go in order of colors on the screen, so the fifth item in the array ([4]) will be color four&#13;" line28="        let packNames = [&quot;default&quot;]&#13;" line29="        let packs = [&#13;" line30="            new ShaderPack(&#13;" line31="                [&quot;light&quot;, &quot;light2&quot;, &quot;dark&quot;, &quot;dark2&quot;, &quot;yellow&quot;, &quot;yellow2&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;],&#13;" line32="                [&#13;" line33="                    [0, 1, 4, 1, 5, 1, 7, 5, 9, 1, 11, 1, 10, 1, 2, 12],&#13;" line34="                    [0, 1, 5, 1, 1, 1, 5, 1, 1, 1, 1, 1, 11, 1, 4, 10],&#13;" line35="                    [0, 13, 14, 2, 2, 7, 8, 6, 12, 6, 12, 12, 15, 14, 15, 15],&#13;" line36="                    [0, 14, 15, 14, 14, 6, 12, 8, 15, 8, 15, 15, 15, 15, 15, 15],&#13;" line37="                    [0, 13, 4, 4, 5, 5, 7, 5, 6, 13, 11, 13, 11, 5, 13, 14],&#13;" line38="                    [0, 5, 5, 5, 5, 5, 5, 5, 7, 5, 13, 5, 13, 5, 5, 13],&#13;" line39="                    [0, 3, 2, 2, 2, 4, 11, 4, 10, 11, 2, 2, 10, 4, 2, 14],&#13;" line40="                    [0, 5, 4, 13, 5, 7, 7, 7, 6, 6, 12, 7, 7, 7, 5, 8],&#13;" line41="                    [0, 9, 10, 11, 12, 6, 8, 6, 8, 8, 12, 8, 8, 9, 12, 8],&#13;" line42="                    [0, 11, 10, 10, 11, 4, 10, 12, 10, 11, 10, 10, 10, 11, 12, 12]&#13;" line43="                ]&#13;" line44="            )&#13;" line45="        ]&#13;" line46="        &#13;" line47="        //for generating the &quot;2&quot; varients&#13;" line48="        let test = []&#13;" line49="        let sample = [0, 1, 4, 1, 5, 1, 7, 5, 9, 1, 11, 1, 10, 1, 2, 12]&#13;" line50="        for (let j = 0; j &lt; 16; j++) {&#13;" line51="            test.push(sample[sample[j]])&#13;" line52="        }&#13;" line53="        return packs[packNames.indexOf(shader)]&#13;" line54="    }&#13;" line55="}" numlines="56"></mutation><next><block type="typescript_statement" id="??lZULxcOF,{j]3qsiC2" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Shader {&#13;" line1="    //Declare initial variables&#13;" line2="    //lookup table&#13;" line3="    //lkupx16: Buffer&#13;" line4="    //Shader pack&#13;" line5="    public refreshShaderLayer: boolean&#13;" line6="    private currentShader: ShaderPack&#13;" line7="    //Decompiled shader pack&#13;" line8="    private colbuf: Buffer[]&#13;" line9="    //Shader augment image&#13;" line10="    public mapLayer: Image&#13;" line11="    //Render and shader buffers&#13;" line12="    private renderBuf: Buffer&#13;" line13="    private shaderBuf: Buffer&#13;" line14="    //zValue&#13;" line15="    private zValue: number&#13;" line16="    //Renderable for shader&#13;" line17="    private shader: scene.Renderable&#13;" line18="    protected updater: any&#13;" line19="    constructor(currentShader: ShaderPack, refreshShaderLayer: boolean, zValue = 0) {&#13;" line20="        /*&#13;" line21="        //build lookup table&#13;" line22="        this.lkupx16 = Buffer.create(16)&#13;" line23="        for (let i = 0; i &lt; 16; i++) {&#13;" line24="            this.lkupx16[i] = (i * 16)&#13;" line25="        }&#13;" line26="        */&#13;" line27="        this.refreshShaderLayer = refreshShaderLayer&#13;" line28="        this.zValue = zValue&#13;" line29="        this.currentShader = currentShader&#13;" line30="        //Unpack Shaderpack&#13;" line31="        this.colbuf = this.currentShader.unpack()&#13;" line32="        //create buffer image&#13;" line33="        this.mapLayer = image.create(160, 120)&#13;" line34="        this.renderBuf = Buffer.create(120)&#13;" line35="        this.shaderBuf = Buffer.create(120)&#13;" line36="        this.shader = scene.createRenderable(this.zValue, (screenImg: Image, camera: scene.Camera) =&gt; {&#13;" line37="            this.shadeImg(screenImg)&#13;" line38="        })&#13;" line39="        this.updateShaderLayer()&#13;" line40="    }&#13;" line41="    protected shadeImg(img:Image) {&#13;" line42="        for (let x = 0; x &lt; img.width; ++x) {&#13;" line43="            img.getRows(x, this.renderBuf)&#13;" line44="            this.mapLayer.getRows(x, this.shaderBuf)&#13;" line45="            for (let y = 0; y &lt; img.height; ++y) {&#13;" line46="                if (this.shaderBuf[y]) {&#13;" line47="                    this.renderBuf[y] = this.colbuf[this.shaderBuf[y]][this.renderBuf[y]]&#13;" line48="                    //use alternate compilation format&#13;" line49="                    //this.renderBuf[y] = (this.colbuf[this.renderBuf[y] + Math.imul(this.shaderBuf[y], 16)])&#13;" line50="                    //alt comp format + lookup table&#13;" line51="                    //this.renderBuf[y] = (this.colbuf[this.renderBuf[y] + this.lkupx16[this.shaderBuf[y]]])&#13;" line52="                }&#13;" line53="            }&#13;" line54="            img.setRows(x, this.renderBuf)&#13;" line55="        }&#13;" line56="    }&#13;" line57="    protected updateShaderLayer() {&#13;" line58="        this.updater = game.currentScene().eventContext.registerFrameHandler(17, () =&gt; {&#13;" line59="            if (this.refreshShaderLayer = true) {&#13;" line60="                this.mapLayer = image.create(160,120)&#13;" line61="            }&#13;" line62="        })&#13;" line63="    }&#13;" line64="    public setNewShader (shader: ShaderPack) {&#13;" line65="        this.colbuf = shader.unpack()&#13;" line66="    }&#13;" line67="    /*&#13;" line68="    //alt function&#13;" line69="    directSetUnpackedShader(array: Buffer) {&#13;" line70="        this.colbuf = shader&#13;" line71="    }&#13;" line72="    */&#13;" line73="    public directSetUnpackedShader (shader: Buffer[]) {&#13;" line74="        this.colbuf = shader&#13;" line75="    }&#13;" line76="    static toScreenX(val: number) {&#13;" line77="        return val - scene.cameraProperty(CameraProperty.Left)&#13;" line78="    }&#13;" line79="    static toScreenY(val: number) {&#13;" line80="        return val - scene.cameraProperty(CameraProperty.Top)&#13;" line81="    }&#13;" line82="    public destroy() {&#13;" line83="        this.shader.destroy()&#13;" line84="        game.currentScene().eventContext.unregisterFrameHandler(this.updater)&#13;" line85="        this.refreshShaderLayer = this.currentShader = this.colbuf = this.mapLayer = this.renderBuf = this.shaderBuf = this.zValue = null&#13;" line86="    }&#13;" line87="}" numlines="88"></mutation><next><block type="typescript_statement" id="M~L.;l87$2f7[yY!Vsat" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class ShaderAttachSprite {&#13;" line1="    public sprite: Sprite&#13;" line2="    public shader: Shader&#13;" line3="    public tint: number&#13;" line4="    public radius: number&#13;" line5="    private currentRad: number&#13;" line6="    public flux: number&#13;" line7="    public smoothness: number&#13;" line8="    public xOffset = 0&#13;" line9="    public yOffset = 0&#13;" line10="    protected updater: any&#13;" line11="    constructor(sprite: Sprite, shader: Shader, tint = 1, radius = 5, flux = 0, smoothness = 1) {&#13;" line12="        this.sprite = sprite&#13;" line13="        this.shader = shader&#13;" line14="        this.tint = tint&#13;" line15="        this.radius = radius&#13;" line16="        this.currentRad = this.radius&#13;" line17="        this.flux = flux&#13;" line18="        this.smoothness = smoothness&#13;" line19="        this.updateLightSource()&#13;" line20="        this.sprite.onDestroyed(() =&gt; {&#13;" line21="            this.destroy()&#13;" line22="        })&#13;" line23="    }&#13;" line24="    protected updateLightSource() {&#13;" line25="        this.updater = game.currentScene().eventContext.registerFrameHandler(24, () =&gt; {&#13;" line26="            if (this.shader.mapLayer != null) {&#13;" line27="                this.updateFlux()&#13;" line28="                this.shader.mapLayer.fillCircle(Shader.toScreenX(this.sprite.x) + this.xOffset, Shader.toScreenY(this.sprite.y) + this.yOffset, Math.round(this.currentRad), this.tint)&#13;" line29="            }&#13;" line30="            if (this.shader.mapLayer === null) {&#13;" line31="                this.destroy()&#13;" line32="            }&#13;" line33="        })&#13;" line34="    }&#13;" line35="    protected updateFlux() {&#13;" line36="        this.smoothness = Math.constrain(this.smoothness, Math.abs(this.flux) * -2, Math.abs(this.flux) * 2)&#13;" line37="        this.currentRad += Math.randomRange(0 - this.smoothness, this.smoothness)&#13;" line38="        //this.currentRad = Math.constrain(this.currentRad, this.radius + this.flux, this.radius - this.flux)&#13;" line39="        if (this.currentRad &gt; this.radius + this.flux || this.currentRad &lt; this.radius - this.flux) {&#13;" line40="            this.currentRad -= this.currentRad - (this.radius + this.flux)&#13;" line41="        }&#13;" line42="    }&#13;" line43="    public destroy() {&#13;" line44="        game.currentScene().eventContext.unregisterFrameHandler(this.updater)&#13;" line45="        this.sprite = this.shader = this.tint = this.radius = this.currentRad = this.flux = this.smoothness = this.xOffset = this.yOffset = this.updater = null&#13;" line46="    }&#13;" line47="}" numlines="48"></mutation><next><block type="typescript_statement" id="0Q]X-j(ndk4iaW5{pg8^" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class TileShader {&#13;" line1="    public image: Image&#13;" line2="    public shader: Shader&#13;" line3="    protected x: number&#13;" line4="    protected y: number&#13;" line5="    protected left: number&#13;" line6="    protected top: number&#13;" line7="    protected right: number&#13;" line8="    protected bottom: number&#13;" line9="    protected updater: any&#13;" line10="    constructor(image: Image, shader: Shader, x: number, y: number) {&#13;" line11="        this.image = image&#13;" line12="        this.shader = shader&#13;" line13="        this.x = x&#13;" line14="        this.y = y&#13;" line15="        this.left = this.x - this.image.width / 2&#13;" line16="        this.top = this.y - this.image.height / 2&#13;" line17="        this.right = this.left + this.image.width&#13;" line18="        this.bottom = this.top + this.image.height&#13;" line19="        this.updateTile()&#13;" line20="    }&#13;" line21="    public setX(x:number) {&#13;" line22="        this.x = x&#13;" line23="        this.left = this.x - this.image.width / 2&#13;" line24="        this.right = this.left + this.image.width&#13;" line25="    }&#13;" line26="    public setY(y: number) {&#13;" line27="        this.y = y&#13;" line28="        this.top = this.y - this.image.height / 2&#13;" line29="        this.bottom = this.top + this.image.height&#13;" line30="    }&#13;" line31="    public setPos(x:number, y: number) {&#13;" line32="        this.x = x&#13;" line33="        this.left = this.x - this.image.width / 2&#13;" line34="        this.right = this.left + this.image.width&#13;" line35="        this.y = y&#13;" line36="        this.top = this.y - this.image.height / 2&#13;" line37="        this.bottom = this.top + this.image.height&#13;" line38="    }&#13;" line39="    public setLeft(left: number) {&#13;" line40="        this.left = left&#13;" line41="        this.x = this.left + this.image.width / 2&#13;" line42="        this.right = this.left + this.image.width&#13;" line43="    }&#13;" line44="    public setTop(top: number) {&#13;" line45="        this.top = top&#13;" line46="        this.y = this.top + this.image.height / 2&#13;" line47="        this.bottom = this.top + this.image.height&#13;" line48="    }&#13;" line49="    public setRight(right: number) {&#13;" line50="        this.right = right&#13;" line51="        this.left = this.right - this.image.width&#13;" line52="        this.x = this.left + this.image.width / 2&#13;" line53="    }&#13;" line54="    public setBottom(bottom: number) {&#13;" line55="        this.bottom = bottom&#13;" line56="        this.top = this.bottom - this.image.height&#13;" line57="        this.y = this.top + this.image.height / 2&#13;" line58="    }    &#13;" line59="    protected updateTile() {&#13;" line60="        this.updater = game.currentScene().eventContext.registerFrameHandler(23, () =&gt; {&#13;" line61="            if (this.shader.mapLayer != null &amp;&amp; Shader.toScreenY(this.top) &lt; scene.screenHeight() &amp;&amp; Shader.toScreenY(this.bottom) &gt; 0 &amp;&amp; Shader.toScreenX(this.left) &lt; scene.screenWidth() &amp;&amp; Shader.toScreenX(this.right) &gt; 0) {&#13;" line62="                helpers.imageBlit(this.shader.mapLayer, Shader.toScreenX(this.left), Shader.toScreenY(this.top), this.image.width, this.image.height, this.image, 0, 0, this.image.width, this.image.height, true, false)&#13;" line63="            }&#13;" line64="            if (this.shader.mapLayer === null) {&#13;" line65="                this.destroy()&#13;" line66="            }&#13;" line67="        })&#13;" line68="    }&#13;" line69="    public destroy() {&#13;" line70="        game.currentScene().eventContext.unregisterFrameHandler(this.updater)&#13;" line71="        this.image = this.shader = this.left = this.top = this.x = this.y = this.right = this.bottom = null&#13;" line72="    }&#13;" line73="}" numlines="74"></mutation></block></next></block></next></block></next></block></statement></block></xml>