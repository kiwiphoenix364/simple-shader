<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="5|LO7!Bkr_!]yRBDKP]j" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="+r:a2wJIs}]ieH~BXJxq" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class ShaderPack {&#13;" line1="    private colorNames: string[]&#13;" line2="    private shaderColorSets: any[]&#13;" line3="    constructor(colorNames: string[], shaderColorSets: any[]) {&#13;" line4="        this.colorNames = colorNames&#13;" line5="        this.shaderColorSets = shaderColorSets&#13;" line6="    }&#13;" line7="    unpack () {&#13;" line8="        //let buf = Buffer.create(16)&#13;" line9="        //for (let i = 0; i &lt; this.shaderColorSets.length; i++) {&#13;" line10="        //    buf = buf.concat(this.shaderColorSets[i])&#13;" line11="        //}&#13;" line12="        let buf = [Buffer.create(0)]&#13;" line13="        for (let i = 0; i &lt; this.shaderColorSets.length; i++) {&#13;" line14="            buf.push(Buffer.fromArray(this.shaderColorSets[i]))&#13;" line15="        }&#13;" line16="        return buf&#13;" line17="    }&#13;" line18="    getTintIdx (color: string) {&#13;" line19="        return this.colorNames.indexOf(color) + 1&#13;" line20="    }&#13;" line21="    static get (shader: string) {&#13;" line22="        //reference for shader pack format&#13;" line23="        //color sets and color set names are in respective orders in their arrays&#13;" line24="        //shader arrays go in order of colors on the screen, so the fifth item in the array ([4]) will be color four&#13;" line25="        let packNames = [&quot;default&quot;]&#13;" line26="        let packs = [&#13;" line27="            new ShaderPack(&#13;" line28="                [&quot;light&quot;, &quot;light2&quot;, &quot;dark&quot;, &quot;dark2&quot;, &quot;yellow&quot;, &quot;yellow2&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;],&#13;" line29="                [&#13;" line30="                    [0, 1, 4, 1, 5, 1, 7, 5, 9, 1, 11, 1, 10, 1, 2, 12],&#13;" line31="                    [0, 1, 5, 1, 1, 1, 5, 1, 1, 1, 1, 1, 11, 1, 4, 10],&#13;" line32="                    [0, 13, 14, 2, 2, 7, 8, 6, 12, 6, 12, 12, 15, 14, 15, 15],&#13;" line33="                    [0, 14, 15, 14, 14, 6, 12, 8, 15, 8, 15, 15, 15, 15, 15, 15],&#13;" line34="                    [0, 13, 4, 4, 5, 5, 7, 5, 6, 13, 11, 13, 11, 5, 13, 14],&#13;" line35="                    [0, 5, 5, 5, 5, 5, 5, 5, 7, 5, 13, 5, 13, 5, 5, 13],&#13;" line36="                    [0, 3, 2, 2, 2, 4, 11, 4, 10, 11, 2, 2, 10, 4, 2, 14],&#13;" line37="                    [0, 5, 4, 13, 5, 7, 7, 7, 6, 6, 12, 7, 7, 7, 5, 8],&#13;" line38="                    [0, 9, 10, 11, 12, 6, 8, 6, 8, 8, 12, 8, 8, 9, 12, 8],&#13;" line39="                    [0, 11, 10, 10, 11, 4, 10, 12, 10, 11, 10, 10, 10, 11, 12, 12]&#13;" line40="                ]&#13;" line41="            )&#13;" line42="        ]&#13;" line43="        &#13;" line44="        //for generating the &quot;2&quot; varients&#13;" line45="        let test = []&#13;" line46="        let sample = [0, 1, 4, 1, 5, 1, 7, 5, 9, 1, 11, 1, 10, 1, 2, 12]&#13;" line47="        for (let j = 0; j &lt; 16; j++) {&#13;" line48="            test.push(sample[sample[j]])&#13;" line49="        }&#13;" line50="        &#13;" line51="        return packs[packNames.indexOf(shader)]&#13;" line52="    }&#13;" line53="}" numlines="54"></mutation><next><block type="typescript_statement" id="NJ:fT1eq1#!0$FN2|3zZ" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class Shader {&#13;" line1="    //Declare initial variables&#13;" line2="    //lookup table&#13;" line3="    //lkupx16: Buffer&#13;" line4="    //Shader pack&#13;" line5="    public refreshShaderLayer: boolean&#13;" line6="    private currentShader: ShaderPack&#13;" line7="    //Decompiled shader pack&#13;" line8="    private colbuf: Buffer[]&#13;" line9="    //Shader augment image&#13;" line10="    public mapLayer: Image&#13;" line11="    //Render and shader buffers&#13;" line12="    private renderBuf: Buffer&#13;" line13="    private shaderBuf: Buffer&#13;" line14="    //zValue&#13;" line15="    private zValue: number&#13;" line16="    //Renderable for shader&#13;" line17="    private shader: scene.Renderable&#13;" line18="    constructor(currentShader: ShaderPack, refreshShaderLayer: boolean, zValue = 0) {&#13;" line19="        /*&#13;" line20="        //build lookup table&#13;" line21="        this.lkupx16 = Buffer.create(16)&#13;" line22="        for (let i = 0; i &lt; 16; i++) {&#13;" line23="            this.lkupx16[i] = (i * 16)&#13;" line24="        }&#13;" line25="        */&#13;" line26="        this.refreshShaderLayer = refreshShaderLayer&#13;" line27="        this.zValue = zValue&#13;" line28="        this.currentShader = currentShader&#13;" line29="        //Unpack Shaderpack&#13;" line30="        this.colbuf = this.currentShader.unpack()&#13;" line31="        //create buffer image&#13;" line32="        this.mapLayer = image.create(160, 120)&#13;" line33="        this.renderBuf = Buffer.create(120)&#13;" line34="        this.shaderBuf = Buffer.create(120)&#13;" line35="        this.shader = scene.createRenderable(this.zValue, (screenImg: Image, camera: scene.Camera) =&gt; {&#13;" line36="            this.shadeImg(screenImg)&#13;" line37="        })&#13;" line38="        this.updateShaderLayer()&#13;" line39="    }&#13;" line40="    protected shadeImg(img:Image) {&#13;" line41="        for (let x = 0; x &lt; img.width; ++x) {&#13;" line42="            img.getRows(x, this.renderBuf)&#13;" line43="            this.mapLayer.getRows(x, this.shaderBuf)&#13;" line44="            for (let y = 0; y &lt; img.height; ++y) {&#13;" line45="                if (this.shaderBuf[y]) {&#13;" line46="                    this.renderBuf[y] = this.colbuf[this.shaderBuf[y]][this.renderBuf[y]]&#13;" line47="                    //use alternate compilation format&#13;" line48="                    //this.renderBuf[y] = (this.colbuf[this.renderBuf[y] + Math.imul(this.shaderBuf[y], 16)])&#13;" line49="                    //alt comp format + lookup table&#13;" line50="                    //this.renderBuf[y] = (this.colbuf[this.renderBuf[y] + this.lkupx16[this.shaderBuf[y]]])&#13;" line51="                }&#13;" line52="            }&#13;" line53="            img.setRows(x, this.renderBuf)&#13;" line54="        }&#13;" line55="    }&#13;" line56="    protected updateShaderLayer() {&#13;" line57="        game.currentScene().eventContext.registerFrameHandler(17, () =&gt; {&#13;" line58="            if (this.refreshShaderLayer) {&#13;" line59="                this.mapLayer = image.create(160,120)&#13;" line60="            }&#13;" line61="        })&#13;" line62="        game.currentScene().eventContext.registerFrameHandler(24, () =&gt; {&#13;" line63="            &#13;" line64="        })&#13;" line65="    }&#13;" line66="    setNewShader (shader: ShaderPack) {&#13;" line67="        this.colbuf = shader.unpack()&#13;" line68="    }&#13;" line69="    /*&#13;" line70="    //alt function&#13;" line71="    directSetUnpackedShader(array: Buffer) {&#13;" line72="        this.colbuf = shader&#13;" line73="    }&#13;" line74="    */&#13;" line75="    directSetUnpackedShader (shader: Buffer[]) {&#13;" line76="        this.colbuf = shader&#13;" line77="    }&#13;" line78="    static toScreenX(val: number) {&#13;" line79="        return val + CameraProperty.Left - 2&#13;" line80="    }&#13;" line81="    static toScreenY(val: number) {&#13;" line82="        return val + CameraProperty.Top - 4&#13;" line83="    }&#13;" line84="}" numlines="85"></mutation><next><block type="typescript_statement" id="*WDUzx`Fp2+yXrm1d*AW" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="class ShaderAttachSprite {&#13;" line1="    public sprite: Sprite&#13;" line2="    public shader: Shader&#13;" line3="    public tint: number&#13;" line4="    public radius: number&#13;" line5="    private currentRad: number&#13;" line6="    public flux: number&#13;" line7="    public smoothness: number&#13;" line8="    public xOffset = 0&#13;" line9="    public yOffset = 0&#13;" line10="    constructor(sprite: Sprite, shader: Shader, tint = 1, radius = 5, flux = 0, smoothness = 1) {&#13;" line11="        this.sprite = sprite&#13;" line12="        this.shader = shader&#13;" line13="        this.tint = tint&#13;" line14="        this.radius = radius&#13;" line15="        this.currentRad = this.radius&#13;" line16="        this.flux = flux&#13;" line17="        this.smoothness = smoothness&#13;" line18="        this.updateLightSources()&#13;" line19="    }&#13;" line20="    protected updateLightSources() {&#13;" line21="        game.currentScene().eventContext.registerFrameHandler(23, () =&gt; {&#13;" line22="            this.updateFlux()&#13;" line23="            this.shader.mapLayer.fillCircle(Shader.toScreenX(this.sprite.x) + this.xOffset, Shader.toScreenY(this.sprite.y) + this.yOffset, Math.round(this.currentRad), this.tint)&#13;" line24="        })&#13;" line25="    }&#13;" line26="    protected updateFlux() {&#13;" line27="        this.smoothness = Math.constrain(this.smoothness, Math.abs(this.flux) * -2, Math.abs(this.flux) * 2)&#13;" line28="        this.currentRad += Math.randomRange(0 - this.smoothness, this.smoothness)&#13;" line29="        //this.currentRad = Math.constrain(this.currentRad, this.radius + this.flux, this.radius - this.flux)&#13;" line30="        if (this.currentRad &gt; this.radius + this.flux || this.currentRad &lt; this.radius - this.flux) {&#13;" line31="            this.currentRad -= this.currentRad - (this.radius + this.flux)&#13;" line32="        }&#13;" line33="    }&#13;" line34="}" numlines="35"></mutation></block></next></block></next></block></statement></block></xml>